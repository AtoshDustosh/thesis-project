1. 以前实现的流程
	- 载入所有需要的数据并建立相应的索引结构	
	- 遍历得到某条sam记录，并提取相关信息
	- 根据sam记录的信息，提取参考基因组的对应区域的碱基序列（根据需要向两侧延伸一小段额外距离）
	- 提取所有与这段来自参考基因组碱基序列有交集的vcf记录
	- 对所有的vcf记录做彼此兼容（整合时不冲突）的组合计算
	- 对每个vcf记录的组合，整合到来自参考基因组的碱基序列上，得到新的序列
	- 将sam记录的SEQ域（read序列）与新序列进行比对，得到比对信息
	- 将比对信息输出到输出文件中，并补充相关的信息（vcf记录的组合等等)

2. 流程的改动设计、
	前两步与之前的操作一致，但是后面的操作因为ksw2的使用以及在重比对策略上的改动，不能直接根据sam记录提取参考基因组的序列，需要首先锁定sam记录里CIGAR中M最多的一段区域，以它为固定位置，向两侧处理。
	提取参考基因组序列的步骤需要放在vcf记录的组合计算之后，因为根据vcf记录的组合情况，如果其中有较长的DEL，可能需要在参考基因组上继续向后提取一小段额外的序列以保证重比对的正确执行。这主要是为了避免出现比对时tseq比原read序列短的情况。

3. 关于vcf数据结构的改动问题
	- 打算把单链表的改成B+树的结构
	- 如果确定了要整合的区域两端，lboud和rbound，那么选取变异时从lbound - len_min_sv的位置的变异开始选取，这样选取的变异全部是snp。既然需要位置，而且还要顺序遍历，所以最好还是使用B+树
	- 关于SV的索引，最好也采用B+树，因为snp的B+树实现以后，稍微改造一下便可以使用
	- 在选取只整合snp或是只整合sv的时候，可以根据vcf记录本身的类型来判断，而不是事先建立两个数据结构，这样实现起来也比较简单。选取sv时也可以通过 lbound - len_max_sv 来加速选取（避免从头开始遍历）。所以将所有的记录使用pos作为键值存入一个bplus tree就可以
	- 由于键值pos可能重复，所以每个叶子节点内的元素为一个链表，存储所有键值为这个pos的vcf记录，由于这类具有相同pos的记录很少，所以在链表上遍历不会耗费过长时间。啊不，直接用数组好了，反正这种情况也不多，就算我free了再malloc拷贝也不会花费太长时间的。。。算了，还是用链表吧，反正区别也不大，而且链表逻辑还简单点。